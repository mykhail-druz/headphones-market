'use client';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import { useMemo, useEffect, useSyncExternalStore, useReducer, Suspense } from 'react';
import { suspend } from 'suspend-react';
import { jsx } from 'react/jsx-runtime';
const _checkAuth = async (projectId, token) => {
  const headers = token ? {
    Authorization: "Bearer ".concat(token)
  } : void 0;
  const res = await fetch("https://".concat(projectId, ".api.sanity.io/v1/users/me"), {
    credentials: "include",
    headers
  });
  const json = await res.json();
  return Boolean(json == null ? void 0 : json.id);
};
const _lazyGroqStore = async () => {
  const pkg = await import('@sanity/groq-store');
  const {
    groqStore
  } = "default" in pkg ? pkg.default : pkg;
  return groqStore;
};
const _lazyEventSourcePolyfill = async () => {
  const pkg = await import('event-source-polyfill');
  const {
    EventSourcePolyfill
  } = "default" in pkg ? pkg.default : pkg;
  return EventSourcePolyfill;
};
function useParams(params) {
  const stringifiedParams = useMemo(() => JSON.stringify(params || null), [params]);
  return useMemo(() => JSON.parse(stringifiedParams), [stringifiedParams]);
}
const _definePreview = _ref => {
  let {
    projectId,
    dataset,
    documentLimit = 3e3,
    subscriptionThrottleMs = 10,
    importEventSourcePolyfill,
    importGroqStore,
    preload,
    onPublicAccessOnly,
    checkAuth,
    includeTypes
  } = _ref;
  if (!projectId) {
    console.warn("No projectId set for createPreviewHook, returning dummy hook");
    const usePreview = function usePreview2() {
      console.warn("The hook returned by createPreviewHook is a dummy as there is no projectId set, returning null");
      return null;
    };
    return usePreview;
  }
  let store;
  return function usePreview(token, query, _params) {
    if (typeof document === "undefined") {
      throw new Error("Calling usePreview outside a browser environment isn't supported. Ensure the component using the hook is only rendering on the client. For example by wrapping it in PreviewSuspense.");
    }
    if (!token && token !== null) {
      throw new Error("No `token` given to usePreview hook, if this is intentional then set it to `null`");
    }
    const params = useParams(_params);
    if (!store) {
      if (onPublicAccessOnly) {
        const hasAuth = checkAuth(projectId, token);
        if (!hasAuth) {
          onPublicAccessOnly();
        }
      }
      const groqStore = importGroqStore();
      store = groqStore({
        projectId,
        dataset,
        documentLimit,
        subscriptionThrottleMs,
        includeTypes,
        token: token === null ? void 0 : token,
        EventSource: token === null ? void 0 : importEventSourcePolyfill(),
        listen: true,
        overlayDrafts: true
      });
    }
    const initial = preload(store, query, params);
    const syncStore = useMemo(() => {
      let snapshot = initial;
      return {
        getSnapshot: () => snapshot,
        subscribe: onStoreChange => {
          const subscription = store.subscribe(query, typeof params === "undefined" ? {} : params, (err, result) => {
            if (err) {
              console.error("Error thrown in the usePreviewHook subscription", err);
              throw err;
            } else {
              snapshot = result;
              onStoreChange();
            }
          });
          return () => subscription.unsubscribe();
        }
      };
    }, [initial, params, query]);
    useEffect(() => {
      const callback = () => {
        store.close();
      };
      window.addEventListener("beforeunload", callback);
      return () => window.removeEventListener("beforeunload", callback);
    }, []);
    return useSyncExternalStore(syncStore.subscribe, syncStore.getSnapshot);
  };
};
const _preloadQuery = (store, query, params) => store.query(query, params);
const definePreview = config => _definePreview(_objectSpread(_objectSpread({}, config), {}, {
  importEventSourcePolyfill: () => suspend(() => _lazyEventSourcePolyfill(), ["@sanity/preview-kit", "event-source-polyfill"]),
  importGroqStore: () => suspend(() => _lazyGroqStore(), ["@sanity/preview-kit", "@sanity/groq-store"]),
  preload: (store, query, params) => suspend(() => _preloadQuery(store, query, params), ["@sanity/preview-kit", "preload", query, JSON.stringify(params != null ? params : null)]),
  checkAuth: (projectId, token) => suspend(() => _checkAuth(projectId, token), ["@sanity/preview-kit", "checkAuth", projectId, token])
}));
function PreviewSuspense(_ref2) {
  let {
    children,
    fallback
  } = _ref2;
  const [mounted, mount] = useReducer(() => true, false);
  useEffect(mount, [mount]);
  return /* @__PURE__ */jsx(Suspense, {
    fallback,
    children: mounted ? children : fallback
  });
}
export { PreviewSuspense, _checkAuth, _definePreview, _lazyEventSourcePolyfill, _lazyGroqStore, definePreview };
//# sourceMappingURL=index.js.map
