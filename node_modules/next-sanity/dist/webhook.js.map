{"version":3,"file":"webhook.js","sources":["../src/webhook/config.ts","../src/webhook/readBody.ts","../src/webhook/parseBody.ts"],"sourcesContent":["import type {PageConfig} from 'next/types'\n\n/**\n * Configurates the API function with the right runtime and body parsing to handle Sanity Webhook events.\n * @public\n */\nexport const config: PageConfig = {\n  api: {\n    /**\n     * Next.js will by default parse the body, which can lead to invalid signatures.\n     */\n    bodyParser: false,\n  },\n  /**\n   * `@sanity/webhook` isn't updated to support the edge runtime yet, and currently requires Node.js APIs such as Buffer.\n   */\n  runtime: 'nodejs',\n}\n","import type {NextApiRequest} from 'next'\n\n/** @internal */\nexport async function _readBody(readable: NextApiRequest): Promise<string> {\n  const chunks = []\n  for await (const chunk of readable) {\n    chunks.push(typeof chunk === 'string' ? Buffer.from(chunk) : chunk)\n  }\n  return Buffer.concat(chunks).toString('utf8')\n}\n","import type {SanityDocument} from '@sanity/types'\nimport sanityWebhook from '@sanity/webhook'\nimport type {NextApiRequest} from 'next'\n\n// As `@sanity/webhook` isn't shipping ESM, extracting from the default export have the best ecosystem support\nconst {isValidSignature, SIGNATURE_HEADER_NAME} = sanityWebhook\n\nimport {_readBody as readBody} from './readBody'\n\n/** @public */\nexport type ParseBody = {\n  /**\n   * If a secret is given then it returns a boolean. If no secret is provided then no validation is done on the signature, and it'll return `null`\n   */\n  isValidSignature: boolean | null\n  body: SanityDocument\n}\n/**\n * Handles parsing the body JSON, and validating its signature. Also waits for Content Lake eventual consistency so you can run your queries\n * without worrying about getting stale data.\n * @public\n */\nexport async function parseBody(\n  req: NextApiRequest,\n  secret?: string,\n  waitForContentLakeEventualConsistency: boolean = true\n): Promise<ParseBody> {\n  let signature = req.headers[SIGNATURE_HEADER_NAME]!\n  if (Array.isArray(signature)) {\n    signature = signature[0]\n  }\n\n  // Read the body into a string\n  const body = await readBody(req)\n  // Then we're able to verify the checksum signature\n  const validSignature = secret ? isValidSignature(body, signature, secret.trim()) : null\n\n  if (validSignature !== false && waitForContentLakeEventualConsistency) {\n    // Wait a second to give Elastic Search time to reach eventual consistency\n    await new Promise((resolve) => setTimeout(resolve, 1000))\n  }\n\n  return {\n    body: body.trim() && JSON.parse(body),\n    isValidSignature: validSignature,\n  }\n}\n"],"names":["config","api","bodyParser","runtime","_readBody","readable","chunks","chunk","push","Buffer","from","concat","toString","isValidSignature","SIGNATURE_HEADER_NAME","sanityWebhook","parseBody","req","secret","waitForContentLakeEventualConsistency","signature","headers","Array","isArray","body","readBody","validSignature","trim","Promise","resolve","setTimeout","JSON","parse"],"mappings":";AAMO,MAAMA,MAAqB,GAAA;EAChCC,GAAK,EAAA;IAIHC,UAAY,EAAA;EACd,CAAA;EAIAC,OAAS,EAAA;AACX,CAAA;ACdA,eAAsBC,UAAUC,QAA2C,EAAA;EACzE,MAAMC,SAAS,EAAC;EAChB,WAAA,MAAiBC,SAASF,QAAU,EAAA;IAC3BC,MAAA,CAAAE,IAAA,CAAK,OAAOD,KAAU,KAAA,QAAA,GAAWE,OAAOC,IAAK,CAAAH,KAAK,IAAIA,KAAK,CAAA;EACpE;EACA,OAAOE,MAAO,CAAAE,MAAA,CAAOL,MAAM,CAAA,CAAEM,SAAS,MAAM,CAAA;AAC9C;ACJA,MAAM;EAACC,gBAAkB;EAAAC;AAAyB,CAAA,GAAAC,aAAA;AAiBlD,eAAsBC,SACpB,CAAAC,GAAA,EACAC,MACA,EACoB;EAAA,IADpBC,qCAAA,uEAAiD,IAC7B;EAChB,IAAAC,SAAA,GAAYH,IAAII,OAAQ,CAAAP,qBAAA,CAAA;EACxB,IAAAQ,KAAA,CAAMC,OAAQ,CAAAH,SAAS,CAAG,EAAA;IAC5BA,SAAA,GAAYA,SAAU,CAAA,CAAA,CAAA;EACxB;EAGM,MAAAI,IAAA,GAAO,MAAMC,SAAA,CAASR,GAAG,CAAA;EAEzB,MAAAS,cAAA,GAAiBR,SAASL,gBAAiB,CAAAW,IAAA,EAAMJ,WAAWF,MAAO,CAAAS,IAAA,EAAM,CAAI,GAAA,IAAA;EAE/E,IAAAD,cAAA,KAAmB,SAASP,qCAAuC,EAAA;IAErE,MAAM,IAAIS,OAAQ,CAACC,WAAYC,UAAW,CAAAD,OAAA,EAAS,GAAI,CAAC,CAAA;EAC1D;EAEO,OAAA;IACLL,MAAMA,IAAK,CAAAG,IAAA,EAAU,IAAAI,IAAA,CAAKC,MAAMR,IAAI,CAAA;IACpCX,gBAAkB,EAAAa;EAAA,CACpB;AACF;"}