declare class Path {
    private pattern;
    private patternRe;
    constructor(pattern: string);
    matches(str: string): boolean;
    toJSON(): string;
}

declare class StreamValue {
    type: 'stream';
    private generator;
    private ticker;
    private isDone;
    private data;
    constructor(generator: () => AsyncGenerator<Value, void, unknown>);
    isArray(): boolean;
    get(): Promise<any>;
    [Symbol.asyncIterator](): AsyncGenerator<Value, void, unknown>;
    _nextTick(): Promise<void>;
}

/**
 * A type of a value in GROQ.
 */
declare type GroqType = 'null' | 'boolean' | 'number' | 'string' | 'array' | 'object' | 'path' | 'datetime';
/**
 * The result of an expression.
 */
declare type Value = AnyStaticValue | StreamValue;
declare type StringValue = StaticValue<string, 'string'>;
declare type NumberValue = StaticValue<number, 'number'>;
declare type NullValue = StaticValue<null, 'null'>;
declare type BooleanValue = StaticValue<boolean, 'boolean'>;
declare type DateTimeValue = StaticValue<DateTime, 'datetime'>;
declare type PathValue = StaticValue<Path, 'path'>;
declare type ObjectValue = StaticValue<Record<string, unknown>, 'object'>;
declare type ArrayValue = StaticValue<unknown[], 'array'>;
declare type AnyStaticValue = StringValue | NumberValue | NullValue | BooleanValue | DateTimeValue | ObjectValue | ArrayValue | PathValue;

declare class StaticValue<P, T extends GroqType> {
    data: P;
    type: T;
    constructor(data: P, type: T);
    isArray(): boolean;
    get(): Promise<any>;
    [Symbol.asyncIterator](): Generator<Value, void, unknown>;
}
declare class DateTime {
    date: Date;
    constructor(date: Date);
    static parseToValue(str: string): Value;
    equals(other: DateTime): boolean;
    add(secs: number): DateTime;
    difference(other: DateTime): number;
    compareTo(other: DateTime): number;
    toString(): string;
    toJSON(): string;
}

declare type Executor<N = ExprNode> = (node: N, scope: Scope) => Value | PromiseLike<Value>;
interface EvaluateOptions {
    root?: any;
    dataset?: any;
    params?: Record<string, unknown>;
    timestamp?: Date;
    identity?: string;
    before?: any;
    after?: any;
    sanity?: {
        projectId: string;
        dataset: string;
    };
}
interface Context {
    timestamp: Date;
    identity: string;
    before: Value | null;
    after: Value | null;
    sanity?: {
        projectId: string;
        dataset: string;
    };
}

declare class Scope {
    params: Record<string, unknown>;
    source: Value;
    value: Value;
    parent: Scope | null;
    context: Context;
    isHidden: boolean;
    constructor(params: Record<string, unknown>, source: Value, value: Value, context: Context, parent: Scope | null);
    createNested(value: Value): Scope;
    createHidden(value: Value): Scope;
}

declare type GroqFunctionArg = ExprNode;
declare type GroqFunction = (args: GroqFunctionArg[], scope: Scope, execute: Executor) => PromiseLike<Value>;
declare type GroqPipeFunction = (base: Value, args: ExprNode[], scope: Scope, execute: Executor) => PromiseLike<Value>;

declare type ObjectAttributeNode = ObjectAttributeValueNode | ObjectConditionalSplatNode | ObjectSplatNode;
/** A node which can be evaluated into a value. */
declare type ExprNode = AccessAttributeNode | AccessElementNode | AndNode | ArrayNode | ArrayCoerceNode | AscNode | ContextNode | DerefNode | DescNode | EverythingNode | FilterNode | FlatMapNode | FuncCallNode | GroupNode | InRangeNode | MapNode | NegNode | NotNode | ObjectNode | OpCallNode | OrNode | ParameterNode | ParentNode | PipeFuncCallNode | PosNode | ProjectionNode | SelectNode | SelectorNode | SliceNode | ThisNode | TupleNode | ValueNode;
declare type OpCall = '==' | '!=' | '>' | '>=' | '<' | '<=' | '+' | '-' | '*' | '/' | '%' | '**' | 'in' | 'match';
/** The base interface for SyntaxNode. */
interface BaseNode {
    type: string;
}
interface AndNode extends BaseNode {
    type: 'And';
    left: ExprNode;
    right: ExprNode;
}
interface ArrayElementNode extends BaseNode {
    type: 'ArrayElement';
    value: ExprNode;
    isSplat: boolean;
}
interface ArrayNode extends BaseNode {
    type: 'Array';
    elements: ArrayElementNode[];
}
interface ArrayCoerceNode extends BaseNode {
    type: 'ArrayCoerce';
    base: ExprNode;
}
interface AscNode extends BaseNode {
    type: 'Asc';
    base: ExprNode;
}
interface ContextNode extends BaseNode {
    type: 'Context';
    key: string;
}
interface DerefNode extends BaseNode {
    type: 'Deref';
    base: ExprNode;
}
interface DescNode extends BaseNode {
    type: 'Desc';
    base: ExprNode;
}
interface EverythingNode extends BaseNode {
    type: 'Everything';
}
interface FuncCallNode extends BaseNode {
    type: 'FuncCall';
    func: GroqFunction;
    name: string;
    args: ExprNode[];
}
interface GroupNode extends BaseNode {
    type: 'Group';
    base: ExprNode;
}
interface InRangeNode extends BaseNode {
    type: 'InRange';
    base: ExprNode;
    left: ExprNode;
    right: ExprNode;
    isInclusive: boolean;
}
interface NegNode extends BaseNode {
    type: 'Neg';
    base: ExprNode;
}
interface NotNode extends BaseNode {
    type: 'Not';
    base: ExprNode;
}
interface ObjectAttributeValueNode extends BaseNode {
    type: 'ObjectAttributeValue';
    name: string;
    value: ExprNode;
}
interface ObjectConditionalSplatNode extends BaseNode {
    type: 'ObjectConditionalSplat';
    condition: ExprNode;
    value: ExprNode;
}
interface ObjectNode extends BaseNode {
    type: 'Object';
    attributes: ObjectAttributeNode[];
}
interface ObjectSplatNode extends BaseNode {
    type: 'ObjectSplat';
    value: ExprNode;
}
interface OpCallNode extends BaseNode {
    type: 'OpCall';
    op: OpCall;
    left: ExprNode;
    right: ExprNode;
}
interface OrNode extends BaseNode {
    type: 'Or';
    left: ExprNode;
    right: ExprNode;
}
interface ParameterNode extends BaseNode {
    type: 'Parameter';
    name: string;
}
interface ParentNode extends BaseNode {
    type: 'Parent';
    n: number;
}
interface PipeFuncCallNode extends BaseNode {
    type: 'PipeFuncCall';
    func: GroqPipeFunction;
    base: ExprNode;
    name: string;
    args: ExprNode[];
}
interface PosNode extends BaseNode {
    type: 'Pos';
    base: ExprNode;
}
interface SelectAlternativeNode extends BaseNode {
    type: 'SelectAlternative';
    condition: ExprNode;
    value: ExprNode;
}
interface SelectNode extends BaseNode {
    type: 'Select';
    alternatives: SelectAlternativeNode[];
    fallback?: ExprNode;
}
interface SelectorNode extends BaseNode {
    type: 'Selector';
}
interface ThisNode extends BaseNode {
    type: 'This';
}
interface TupleNode extends BaseNode {
    type: 'Tuple';
    members: Array<ExprNode>;
}
interface ValueNode<P = any> {
    type: 'Value';
    value: P;
}
interface FlatMapNode extends BaseNode {
    type: 'FlatMap';
    base: ExprNode;
    expr: ExprNode;
}
interface MapNode extends BaseNode {
    type: 'Map';
    base: ExprNode;
    expr: ExprNode;
}
interface AccessAttributeNode extends BaseNode {
    type: 'AccessAttribute';
    base?: ExprNode;
    name: string;
}
interface AccessElementNode extends BaseNode {
    type: 'AccessElement';
    base: ExprNode;
    index: number;
}
interface SliceNode extends BaseNode {
    type: 'Slice';
    base: ExprNode;
    left: number;
    right: number;
    isInclusive: boolean;
}
interface FilterNode extends BaseNode {
    type: 'Filter';
    base: ExprNode;
    expr: ExprNode;
}
interface ProjectionNode extends BaseNode {
    type: 'Projection';
    base: ExprNode;
    expr: ExprNode;
}

interface ParseOptions {
    params?: Record<string, unknown>;
    mode?: 'normal' | 'delta';
}

/**
 * Parses a GROQ query and returns a tree structure.
 */
declare function parse(input: string, options?: ParseOptions): ExprNode;

/**
 * Evaluates a query.
 */
declare function evaluateQuery(tree: ExprNode, options?: EvaluateOptions): Value | PromiseLike<Value>;

export { evaluateQuery as evaluate, parse };
